import { MessageElements } from './messages';
import { Names } from '../../../types/names';
import { DeepChat } from '../../../deepChat';
import { Avatars } from '../../../types/avatars';
import { Response } from '../../../types/response';
import { IntroPanel } from '../introPanel/introPanel';
import { HTMLClassUtilities } from '../../../types/html';
import { ProcessedTextToSpeechConfig } from './textToSpeech/textToSpeech';
import { MessageContentI, Overwrite } from '../../../types/messagesInternal';
import { MessageElementsStyles, MessageRoleStyles, MessageStyles, UserContent } from '../../../types/messages';

export declare class MessagesBase {
    messageElementRefs: MessageElements[];
    textToSpeech?: ProcessedTextToSpeechConfig;
    submitUserMessage?: (content: UserContent) => void;
    readonly elementRef: HTMLElement;
    readonly messageStyles?: MessageStyles;
    readonly messages: MessageContentI[];
    readonly htmlClassUtilities: HTMLClassUtilities;
    readonly textElementsToText: [MessageElements, string][];
    protected _introPanel?: IntroPanel;
    protected readonly _avatars?: Avatars;
    protected readonly _names?: Names;
    private _remarkable;
    private readonly _onMessage?;
    constructor(deepChat: DeepChat);
    private static createContainerElement;
    addNewTextMessage(text: string, role: string, overwrite?: Overwrite): MessageElements;
    private overwriteText;
    protected createAndAppendNewMessageElement(text: string, role: string): MessageElements;
    createNewMessageElement(text: string, role: string): MessageElements;
    protected static isTemporaryElement(elements: MessageElements): boolean;
    protected createMessageElements(text: string, role: string): MessageElements;
    protected static createBaseElements(): MessageElements;
    private addInnerContainerElements;
    applyCustomStyles(elements: MessageElements | undefined, role: string, media: boolean, otherStyles?: MessageRoleStyles | MessageElementsStyles): void;
    static createMessageContent(content: Response): MessageContentI;
    removeLastMessage(): void;
    isLastMessageError(): boolean | undefined;
    sendClientUpdate(message: MessageContentI, isHistory?: boolean): void;
    renderText(bubbleElement: HTMLElement, text: string): void;
    protected refreshTextMessages(): void;
}
//# sourceMappingURL=messagesBase.d.ts.map